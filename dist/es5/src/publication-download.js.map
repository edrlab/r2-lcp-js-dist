{"version":3,"file":"publication-download.js","sourceRoot":"","sources":["../../../src/publication-download.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as request from \"request\";\nimport * as requestPromise from \"request-promise-native\";\nimport { JSON as TAJSON } from \"ta-json-x\";\n\nimport { streamToBufferPromise } from \"@r2-utils-js/_utils/stream/BufferUtils\";\nimport { injectFileInZip } from \"@r2-utils-js/_utils/zip/zipInjector\";\n\nimport { LCP } from \"./parser/epub/lcp\";\n\nconst debug = debug_(\"r2:lcp#publication-download\");\n\nconst IS_DEV = (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"dev\");\n\nexport async function downloadEPUBFromLCPL(filePath: string, dir: string, destFileName: string): Promise<string[]> {\n\n    return new Promise<string[]>(async (resolve, reject) => {\n\n        const lcplStr = fs.readFileSync(filePath, { encoding: \"utf8\" });\n        // debug(lcplStr);\n        const lcplJson = global.JSON.parse(lcplStr);\n        const lcpl = TAJSON.deserialize<LCP>(lcplJson, LCP);\n        if (lcpl.Links) {\n            const pubLink = lcpl.Links.find((link) => {\n                return link.Rel === \"publication\";\n            });\n            if (pubLink) {\n\n                const destPathTMP = path.join(dir, destFileName + \".tmp\");\n                const destPathFINAL = path.join(dir, destFileName);\n\n                const failure = (err: any) => {\n                    debug(err);\n                    reject(pubLink.Href + \" (\" + err + \")\");\n                };\n\n                const success = async (response: request.RequestResponse) => {\n                    if (IS_DEV) {\n                        Object.keys(response.headers).forEach((header: string) => {\n                            debug(header + \" => \" + response.headers[header]);\n                        });\n                    }\n\n                    if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n                        let failBuff: Buffer;\n                        try {\n                            failBuff = await streamToBufferPromise(response);\n                        } catch (buffErr) {\n                            if (IS_DEV) {\n                                debug(buffErr);\n                            }\n                            failure(response.statusCode);\n                            return;\n                        }\n                        try {\n                            const failStr = failBuff.toString(\"utf8\");\n                            if (IS_DEV) {\n                                debug(failStr);\n                            }\n                            try {\n                                const failJson = global.JSON.parse(failStr);\n                                if (IS_DEV) {\n                                    debug(failJson);\n                                }\n                                failJson.httpStatusCode = response.statusCode;\n                                failure(failJson);\n                            } catch (jsonErr) {\n                                if (IS_DEV) {\n                                    debug(jsonErr);\n                                }\n                                failure({ httpStatusCode: response.statusCode, httpResponseBody: failStr });\n                            }\n                        } catch (strErr) {\n                            if (IS_DEV) {\n                                debug(strErr);\n                            }\n                            failure(response.statusCode);\n                        }\n                        return;\n                    }\n\n                    const destStreamTMP = fs.createWriteStream(destPathTMP);\n                    response.pipe(destStreamTMP);\n                    // response.on(\"end\", () => {\n                    // });\n                    destStreamTMP.on(\"finish\", () => {\n\n                        const zipError = (err: any) => {\n                            debug(err);\n                            reject(destPathTMP + \" (\" + err + \")\");\n                        };\n\n                        const doneCallback = () => {\n                            setTimeout(() => {\n                                fs.unlinkSync(destPathTMP);\n                            }, 1000);\n\n                            resolve([destPathFINAL, pubLink.Href]);\n                        };\n                        const zipEntryPath = \"META-INF/license.lcpl\";\n\n                        injectFileInZip(destPathTMP, destPathFINAL, filePath, zipEntryPath, zipError, doneCallback);\n                    });\n                };\n\n                // No response streaming! :(\n                // https://github.com/request/request-promise/issues/90\n                const needsStreamingResponse = true;\n                if (needsStreamingResponse) {\n                    request.get({\n                        headers: {},\n                        method: \"GET\",\n                        uri: pubLink.Href,\n                    })\n                        .on(\"response\", success)\n                        .on(\"error\", failure);\n                } else {\n                    let response: requestPromise.FullResponse;\n                    try {\n                        // tslint:disable-next-line:await-promise no-floating-promises\n                        response = await requestPromise({\n                            headers: {},\n                            method: \"GET\",\n                            resolveWithFullResponse: true,\n                            uri: pubLink.Href,\n                        });\n                    } catch (err) {\n                        failure(err);\n                        return;\n                    }\n\n                    await success(response);\n                }\n            }\n        }\n    });\n}\n"]}